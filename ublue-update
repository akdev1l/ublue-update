#!/usr/bin/env python3

import psutil
import notify2
import os
import subprocess
import logging
import configparser
import argparse

default_config = """
[checks]
battery_percent = 50
cpu_load = 50
[notify]
dbus_notify = True
"""

dbus_notify = True

# setup logging
logging.basicConfig(
    format="[%(asctime)s] %(name)s:%(levelname)s | %(message)s",
    level=os.getenv("UBLUE_LOG", default=logging.INFO),
)
log = logging.getLogger(__name__)


def check_cpu_load(max_cpu_load):
    # get load average percentage in last 5 minutes:
    # https://psutil.readthedocs.io/en/latest/index.html?highlight=getloadavg
    cpu_load = psutil.getloadavg()[1] / psutil.cpu_count() * 100
    return {
        "passed": cpu_load < max_cpu_load,
        "message": f"CPU load is above {max_cpu_load}%",
    }


def check_network_status():
    network_status = psutil.net_if_stats()
    # check each network interface
    network_up = False
    for key in network_status.keys():
        if key != "lo":
            if network_status[key][0]:
                network_up = True
                break
    return {"passed": network_up, "message": "Network not enabled"}


def check_battery_status(min_battery_percent):
    battery_status = psutil.sensors_battery()
    # null safety on the battery variable, it returns "None"
    # when the system doesn't have a battery
    battery_pass = True
    if battery_status is not None:
        battery_pass = (
            battery_status.percent > min_battery_percent or battery_status.power_plugged
        )
    return {
        "passed": battery_pass,
        "message": f"Battery less than {min_battery_percent}%",
    }


def check_inhibitors(config):
    min_battery_percent = float(config["checks"]["battery_percent"])
    max_cpu_load = float(config["checks"]["cpu_load"])

    update_inhibitors = [
        check_network_status(),
        check_battery_status(min_battery_percent),
        check_cpu_load(max_cpu_load),
    ]

    failures = []
    update_checks_failed = False
    for inhibitor_result in update_inhibitors:
        if not inhibitor_result["passed"]:
            update_checks_failed = True
            failures.append(inhibitor_result["message"])

    # log the failed update
    if update_checks_failed:
        # notify systemd that the checks have failed,
        # systemd will try to rerun the unit
        exception_log = "\n - ".join(failures)
        raise Exception(f"update failed to pass checks: \n - {exception_log}")


def load_config():
    # load config values
    config_paths = [
        os.path.expanduser("~/.config/ublue-update/ublue-update.conf"),
        "/etc/ublue-update/ublue-update.conf",
        "/usr/etc/ublue-update/ublue-update.conf",
    ]

    # search for the right config
    config_path = ""
    for path in config_paths:
        if os.path.isfile(path):
            config_path = path
            break

    # if there's no config, create one
    if config_path == "":
        config_path = config_paths[0]
        os.makedirs(os.path.dirname(config_path))
        with open(config_path, "w") as f:
            f.write(default_config)

    config = configparser.ConfigParser()
    config.read(config_path)
    return config


def run_updates():
    root_dir = "/etc/ublue-update.d/"

    for root, dirs, files in os.walk(root_dir):
        for file in files.sort():
            full_path = root_dir + "/" + str(file)

            executable = os.access(full_path, os.X_OK)
            if executable:
                out = subprocess.run(
                    [full_path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT
                )

                if out.returncode != 0:
                    log.info(f"{full_path} returned error code: {out.returncode}")
                    log.info(f"Program output: \n {out.stdout}")
                    if dbus_notify:
                        notify2.Notification(
                            "System Updater",
                            f"Error in update script: {file}, check logs for more info",
                            "notification-message-im").show()
            else:
                log.info(f"could not execute file {full_path}")


def main():
    config = load_config()
    dbus_notify = config["notify"]["dbus_notify"]
    # setup argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--force", action="store_true",
                        help="force manual update, skipping update checks")
    args = parser.parse_args()

    if dbus_notify:
        notify2.init('ublue-update')

    if not args.force:
        check_inhibitors(config)
    # system checks passed
    if dbus_notify:
        notify2.Notification(
            "System Updater",
            "System passed checks, updating ...",
            "notification-message-im").show()

    run_updates()
    if dbus_notify:
        notify2.Notification(
            "System Updater",
            "System update complete, reboot for changes to take effect",
            "notification-message-im").show()


if __name__ == "__main__":
    raise SystemExit(main())
